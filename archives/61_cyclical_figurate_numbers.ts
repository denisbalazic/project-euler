/**
 * Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:
 * Triangle        P3,n=n(n+1)/2        1, 3, 6, 10, 15, ...
 * Square        P4,n=n2        1, 4, 9, 16, 25, ...
 * Pentagonal        P5,n=n(3n−1)/2        1, 5, 12, 22, 35, ...
 * Hexagonal        P6,n=n(2n−1)        1, 6, 15, 28, 45, ...
 * Heptagonal        P7,n=n(5n−3)/2        1, 7, 18, 34, 55, ...
 * Octagonal        P8,n=n(3n−2)        1, 8, 21, 40, 65, ...
 *
 * The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties:
 *
 *     1.The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).
 *     2.Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), is represented by a different number in the set.
 *     3.This is the only set of 4-digit numbers with this property.
 *
 * Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal,
 * is represented by a different number in the set.
 */

const triangle = (n: number): number => n * (n + 1) / 2;
const square = (n: number): number => n ** 2;
const pentagonal = (n: number): number => n * (3 * n - 1) / 2;
const hexagonal = (n: number): number => n * (2 * n - 1);
const heptagonal = (n: number): number => n * (5 * n - 3) / 2;
const octagonal = (n: number): number => n * (3 * n - 2);

const polygonalArrayGenerators = [triangle, square, pentagonal, hexagonal, heptagonal, octagonal];

const generatePolygonalArray = (polygonalFunc: (n: number) => number, min: number, max: number) => {
    const polygonalArr: number[] = [];
    let polygonalNum: number = 0;
    let i = 1;
    while (polygonalNum <= max) {
        polygonalNum = polygonalFunc(i);
        if (polygonalNum >= min && polygonalNum <= max) polygonalArr.push(polygonalNum);
        i++;
    }

    return polygonalArr;
}

const generatePolygonalArrays = (generators: ((n: number) => number)[]) => generators.map(g => generatePolygonalArray(g, 1000, 9999));

const checkCyclic = (a: number, b: number): boolean => String(a).slice(2) === String(b).slice(0, 2);

//Loop through polygonal arrays and filter them by cyclic criteria until not more than one left in each array
const reducePolygonalArrays = (polygonalArrays: number[][]) => {
    const filteredArrays: number[][] = [...polygonalArrays];

    while(filteredArrays.some(arr => arr.length > 1)) {
        for (let i = 1; i < filteredArrays.length; i++) {
            filteredArrays[i] = filteredArrays[i].filter(el => filteredArrays[i - 1].some(prevEl => checkCyclic(prevEl, el)));
        }
        filteredArrays[0] = filteredArrays[0].filter(el => filteredArrays[filteredArrays.length - 1].some(prevEl => checkCyclic(prevEl, el)));
    }

    return filteredArrays;
}

const permuteArray = (inputArr: any[]) => {
    let result: any[] = [];

    const permute = (arr, m = []) => {
        if (arr.length === 0) {
            result.push(m)
        } else {
            for (let i = 0; i < arr.length; i++) {
                let curr = arr.slice();
                let next = curr.splice(i, 1);
                permute(curr.slice(), m.concat(next))
            }
        }
    }

    permute(inputArr)

    return result;
}

const findCyclicNums = (polyArrays: number[][]): number[] => {
    const permutations = permuteArray(polyArrays);
    for(const polyArray of permutations) {
        const cyclicNums = reducePolygonalArrays(polyArray)
        if(cyclicNums.every(cn => cn.length === 1)) {
            return cyclicNums.map(cn => Number(cn.toString()));
        }
    }
    return [];
}

const polygonalArrays = generatePolygonalArrays(polygonalArrayGenerators);
const cyclicNums = findCyclicNums(polygonalArrays);
const sum = cyclicNums.reduce((acc, curr) => acc + curr, 0);

console.log(cyclicNums);
console.log(sum);





//This algorithm was computational too heavy so I abandoned it; left it here for possible future use :)
//It returns all possible combinations of elements from given arrays
const permutePolygonal = (polygonalArrays: number[][]) => {
    let register = polygonalArrays.map(p => 0);
    let registerArr: number[][] = [register];

    let p = 0;

    while (p < register.length) {
        const nextGenerationRegisterArr: number[][] = [];
        for (let i = 0; i < registerArr.length; i++) {
            //select polygonal array
            for (let j = 0; j < polygonalArrays[p].length; j++) {
                const arr = [...registerArr[i]];
                arr[p] = polygonalArrays[p][j];
                nextGenerationRegisterArr.push(arr);
            }
        }
        p++;
        registerArr = [...nextGenerationRegisterArr];
    }

    return registerArr;
}
